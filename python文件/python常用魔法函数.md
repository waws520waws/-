# [python常用魔法函数](https://www.cnblogs.com/small-office/p/9337297.html)

## 1、\_\_init\_\_():

所有类的超类object，有一个默认包含pass的\_\_init__()实现，这个函数会在对象初始化的时候调用，我们可以选择实现，也可以选择不实现，一般建议是实现的，不实现对象属性就不会被初始化，虽然我们仍然可以对其进行赋值，但是它已经成了隐式的了，编程时显示远比隐式的更好，看下面的小栗子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720134922664-1163893342.png)

 

 

我们可以通过vars函数获知显示声明的属性，但是隐式的就无法获知了，这并不值得提倡，但是在知道参数的情况下我们还是可以对其进行赋值的，如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720134950858-505777909.png)

 

不论怎么样，显示的初始化属性是一个好习惯。

## 2、\_\_str\_\_():

直接打印对象的实现方法，\_\_str\_\_是被print函数调用的，一般都是return一个什么东西，这个东西应该是以字符串的形式表现的。如果不是要用str()函数转换，我们可以直接print的对象都是实现了\__str__这个方法的，比如dict。看下面的例子。

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135032851-1348422206.png)

 

 

\_\_str\_\_是dict其中的一个方法，这个方法的实现赋予了它直接被print的能力，知道这些，我们就可以给自己的类定义这个方法使其可以print了，例子如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135050414-686464843.png)

 

 

但是这个**函数返回值必须为string**，否则会抛异常：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135108906-1500374836.png)

 

 

## 3、\_\_new\_\_():

在object类中存在一个静态的\_\_new\_\_(`cls, *args, **kwargs`)方法，该方法需要传递一个参数cls，cls表示需要实例化的类，此参数在实例化时由Python解释器自动提供，**\_\_new\_\_方法必须有返回值，且返回的是被实例化的实例**，只有在该实例返回后才会调用\_\_init\_\_来进行初始化，初始化所用的实例就是\_\_new\_\_返回的结果，也就可以认为是self，我们来看下面的例子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135121998-144971867.png)

 

 

可以看到，在实例化时候，先执行\_\_new\_\_再执行\_\_init\_\_，而且python会自动传入我们希望实例化的类，的这里我们显示的调用了object的\_\_new\_\_，也可以调用其他的父类的\_\_new\_\_，那么如果我们定义了\_\_new\_\_，但是并没有返回一个本身实例，会发生什么事呢？例子如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135133224-1772059509.png)

 

 

可以看到本身的\_\_init\_\_函数并未被调用，而是调用了str的\_\_init\_\_，可能这样并不直观，那么换一个实例返回，如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135146221-377736095.png)

 

 ![Snipaste_2021-02-20_13-40-01](.\images\Snipaste_2021-02-20_13-40-01.png)

这个就比较明显了，另一个实例的\_\_init\_\_被调用了。

## 4、\_\_unicode\_\_():

\_\_unicode\_\_()方法是**在一个对象上调用unicode()时被调用的**。因为Django的数据库后端会返回Unicode字符串给model属性，所以我们通常会给自己的model写一个\_\_unicode\_\_()方法。**如果定义了\_\_unicode\_\_()方法但是没有定义\_\_str\_\_()方法，Django会自动提供一个\_\_str\_\_()方法调用 \_\_unicode\_\_()方法，然后把结果转换为UTF-8编码的字符串对象**，所以在一般情况下，只定义\_\_unicode\_\_()方法，让 Django来处理字符串对象的转换，看一个小栗子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135223100-1024556924.png)

 

在django中，虽然没有定义\_\_str\_\_，但是django会将\_\_unicode\_\_转为了str，当然你调用unicode更加是没有问题的。

## 5、\_\_call\_\_():

**对象通过提供\_\_call\_\_()方法可以模拟函数的行为，如果一个对象提供了该方法，就可以像函数一样使用它**，还是用例子进行说明。

![](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135408034-134570949.png)

 

 

可以看到，**我们在像使用函数一样使用类，实在是很有意思的事**。

## 6、\_\_len\_\_():

**len调用后会调用对象的\_\_len\_\_函数，我们可以为其定制输出**，如下例子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135419964-315615857.png)

 

 

但是**该函数要求我们返回的值必须为int**，否则会报错，如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135432278-856652499.png)

 

 

## 7、\_\_repr\_\_():

函数str() 用于将值转化为适于人阅读的形式，而repr() **转化为供解释器读取的形式**，某对象没有适于人阅读的解释形式的话，str() 会返回与repr()，所以print展示的都是str的格式。例子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135739029-801505823.png)

 

 ![Snipaste_2021-02-20_14-16-59](.\images\Snipaste_2021-02-20_14-16-59.png)

![Snipaste_2021-02-20_14-18-17](.\images\Snipaste_2021-02-20_14-18-17.png)

## 8、\_\_setattr\_\_():

该函数可以设置函数的属性，文字不知怎么描述，直接上例子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135749190-147475221.png)

 

 ![Snipaste_2021-02-20_14-23-29](.\images\Snipaste_2021-02-20_14-23-29.png)

从上例可以看出，\_\_setattr\_\_函数可以支持对象增加属性，我们可以有计划的修改增加属性的内容。

## 9、\_\_getattr\_\_()

获取对象属性，只有在属性没有找到的时候调用，还是看例子：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135619200-2000547139.png)

 

第一个属性可以找到，所以不会调\_\_getattr\_\_，第二个属性找不到，所以会调用到。

## 10、\_\_getattribute\_\_()：

  该函数和上面介绍的\_\_getattr\_\_很像，都是获取属性，但是**\_\_getattr\_\_是在属性不存在时被调用，而\_\_getattribute\_\_是无条件被调用**，这样会方便我们做一些控制，需要注意，**一旦定义了\_\_getattribute\_\_，则\_\_getattr\_\_不再会被调用，除非显式调用**，例子如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135835921-1076248945.png)

 

## 11、\_\_delattr\_\_():

本函数的作用是删除属性，实现了该函数的类可以用del 命令来删除属性，下面还是看个例子。

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135903379-927397263.png)

 

## 12、\_\_setitem\_\_():

该**函数可以给对象赋值**，我们可以**以下标的方式对其进行操作**，下面看个例子。

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135923454-1059871096.png)

 

## 13、\_\_getitem\_\_():

与上函数相反，\_\_getitem\_\_可以**使对象支持已下标的方式获取值**，例子如下：

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720135951195-1537688272.png)

 

这一类魔法函数对我们来说最大的好处是可以增加代码的优雅程度，并且可以方便的进行流程的控制，上面的例子，我们向操作字典一样在操作一个对象，并且在赋值与取值时都进行了变更，实在是比较好玩。

## 14、\_\_delitem\_\_():

  该函数**支持以下标方式删除对象数据**，实现了这三个函数，这个类就像字典一样，具备了基本的增删查功能，有时候这样写会很方便。

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720140012527-531074201.png)

 

## 15、\_\_iter\_\_():

只要定义了\_\_iter\_\_()方法对象，就**可以使用迭代器访问，这意味着，我们可以迭代我们自己定义的对象**，具体请看第三章，例子如下。

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720140035542-116550977.png)

 

![Snipaste_2021-02-20_14-59-45](.\images\Snipaste_2021-02-20_14-59-45.png)

## 16、\_\_del\_\_():

这可以说是一个**析构器**，或者回收器，在**对象引用数降到0时执行，有时可能还需要等一会再执行，所以一般不推荐使用**，但是在代码中我们偶尔可以用它来实现一些必须要做的，但是并不紧急的事，下面是个例子。

![img](https://images2018.cnblogs.com/blog/1365566/201807/1365566-20180720140057911-649322787.png)

 

可以看到，在对象不再被引用后，会运行\_\_del\_\_函数。